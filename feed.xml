<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zooon0.github.io</id><title>JunYoung's Blog</title><subtitle>공부한 것들/관심있는내용/잡담 올리는 블로그 현재 주 관심사는 CS/수학/독서/음악/게임/라즈베리파이/하드웨어 등</subtitle> <updated>2021-05-08T21:20:28+09:00</updated> <author> <name>JunYoung Yeom# change to your full name</name> <uri>https://zooon0.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://zooon0.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 JunYoung Yeom# change to your full name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Hoffman/Kunze Linear Algebra Chapter 1</title><link href="https://zooon0.github.io/posts/HK-Linear-Algebra-Chap1/" rel="alternate" type="text/html" title="Hoffman/Kunze Linear Algebra Chapter 1" /><published>2021-05-08T17:40:55+09:00</published> <updated>2021-05-08T17:40:55+09:00</updated> <id>https://zooon0.github.io/posts/HK-Linear-Algebra-Chap1/</id> <content src="https://zooon0.github.io/posts/HK-Linear-Algebra-Chap1/" /> <author> <name>JunYoung Yeom# change to your full name</name> </author> <category term="수학" /> <category term="선형대수" /> <summary> 다변수 공부하다 선대내용이 자주나와서 복습하려고 읽기 시작함. 사실 다변수 리만적분까진 선대내용이 문제될일은없는데 Differential Form 나오면서 Multilinear algebra니 Tensor니 하는게 나오는데 예전 기억에 마침 Hoffman/Kunze Linear Algebra 책에 관련 내용이 있었던 게 기억나서 선대복습할겸 보기시작했다. Chapter 1은 행렬인데 뭐 사실 특별한 내용은 거의 없고 그냥 오랫만에 복습… 근데 오랫만에 보니까 뭔가 처음보는 기분인거같긴하다 ㅋㅋㅋ 내용이야 알고있지만 증명은 새롭군… 아 그리고 좋은거 하나 배움 \[AB = C\] 라 하고, \(C\)의 row를 \(\gamma_{1}, \cdots, \gamma_{m}\), \(B\)의 ro... </summary> </entry> <entry><title>쿼드 트리 뒤집기</title><link href="https://zooon0.github.io/posts/QuadTree.md/" rel="alternate" type="text/html" title="쿼드 트리 뒤집기" /><published>2021-02-11T18:30:55+09:00</published> <updated>2021-02-11T22:07:20+09:00</updated> <id>https://zooon0.github.io/posts/QuadTree.md/</id> <content src="https://zooon0.github.io/posts/QuadTree.md/" /> <author> <name>JunYoung Yeom# change to your full name</name> </author> <category term="CS" /> <category term="알고리즘" /> <summary> 문제는 여기 #include &amp;lt;iostream&amp;gt; using namespace std; typedef struct quadtree { char color; quadtree *leftupper; quadtree *rightupper; quadtree *leftbelow; quadtree *rightbelow; } quadtree; typedef struct MyTuple { char *first; quadtree *second; } MyTuple; MyTuple makeTree(quadtree *root, char *data) { if (data[0] == 'x') { root-&amp;gt;color = data[0... </summary> </entry> <entry><title>DP에서 주의할 점</title><link href="https://zooon0.github.io/posts/Dont-Use-Global-Variable/" rel="alternate" type="text/html" title="DP에서 주의할 점" /><published>2021-02-03T23:55:55+09:00</published> <updated>2021-02-03T23:55:55+09:00</updated> <id>https://zooon0.github.io/posts/Dont-Use-Global-Variable/</id> <content src="https://zooon0.github.io/posts/Dont-Use-Global-Variable/" /> <author> <name>JunYoung Yeom# change to your full name</name> </author> <category term="CS" /> <category term="알고리즘" /> <summary> 알고리즘책 연습문제 잠깐 해보는데 귀찮다고 배열을 전역변수로 썼다가 디버깅하는데 몇시간 날려먹었다… 전역변수 쓰지말자 public static double binomial(int N, int k, double p) { if (N &amp;lt; 0 || k &amp;lt; 0) return 0.0; if (arr[N][k] != 0.0) { return arr[N][k]; } if (N == k) { arr[N][k] = Math.pow(p, N); return arr[N][k]; } else if (k == 0) { ... </summary> </entry> <entry><title>밑바닥부터 시작하는 딥러닝 3</title><link href="https://zooon0.github.io/posts/DLFS-3rd/" rel="alternate" type="text/html" title="밑바닥부터 시작하는 딥러닝 3" /><published>2021-02-02T22:53:55+09:00</published> <updated>2021-02-03T02:08:11+09:00</updated> <id>https://zooon0.github.io/posts/DLFS-3rd/</id> <content src="https://zooon0.github.io/posts/DLFS-3rd/" /> <author> <name>JunYoung Yeom# change to your full name</name> </author> <category term="CS" /> <category term="ML" /> <summary> Ch5 역전파 Ch4에서 사용한 수치미분방법은 딥러닝에서 손실함수의 gradient를 계산하기에는 너무 오래 걸린다. 역전파로 기울기를 계산하는 것은, 일종의 dynamic programming 인 데다가, 모델의 손실 함수를 이미 미분 식이 알려진 함수들의 합성으로 표현하여, chain rule로 전체 gradient를 표기한다. 그렇게 하면 많은 계산의 중복을 줄일 수 있다. 사실 차이가 그렇게까지 크진 않을 줄 알았는데, 막상 테스트해보니 차이가 엄청 컸다. Time complexity의 분석을 해 보자. 우선 편의상 데이터는 \(n\)차원 데이터 \(1\)개가 주어졌다고 하자.(나중에 batch의 크기를 곱해 주면 되니까) \(x \in \mathbb{R}^n\)이 주어진 데이터라고... </summary> </entry> <entry><title>따라 하며 배우는 데이터 과학 2</title><link href="https://zooon0.github.io/posts/DS-STUDY-2nd/" rel="alternate" type="text/html" title="따라 하며 배우는 데이터 과학 2" /><published>2021-02-01T23:00:00+09:00</published> <updated>2021-02-02T23:46:21+09:00</updated> <id>https://zooon0.github.io/posts/DS-STUDY-2nd/</id> <content src="https://zooon0.github.io/posts/DS-STUDY-2nd/" /> <author> <name>JunYoung Yeom# change to your full name</name> </author> <category term="CS" /> <category term="ML" /> <summary> Ch7 데이터의 종류에 따른 기본적인 분석 기법들을 설명한다. 수량형 변수 시각화를 해본다 요약 통계량을 계산해본다 qqplot(), qqline()으로 데이터의 정규성을 검사한다. t.test() 로 일변량 t-검정과 신뢰구간을 구할 수 있다. 예시 t.test(hwy, mu = mu0, alternative = "greater") 이상점이 있는지 살피고 이상점이 있는 경우 로버스트 통계량을 계산해본다. boxplot()으로 이상점을 찾을 수 있다. boxplot()에서 이상점은 \(\left[Q1 - 1.5 \times IQR, \; Q3 + 1.5 \times IQR\right] \qquad (IQR = Q3 - Q1)\) 의 바깥에 있는 점을 말한다. 로버스트 통계 방법은 ... </summary> </entry> </feed>
